data = maxSizePred,
size = 4, shape = 17, color = c("darkgray", 1))
pPred2 <- geom_point(aes(tempC, size, linetype = NULL),
data = maxSizePred,
size = 2, shape = 17, color = "white")
# final plot
maxSizePlot + maxObs + maxObs2 + pPred + pPred2
ggsave("./figs/ipm_temp.pdf", width = 3.5, height = 3.5)
sizeObs
maxSizeHistObs <- sizeObs$maxSize[1]
maxSizeModObs <- sizeObs$maxSize[2]
maxSizeHistObs
maxSizeModObs
maxSizeHistPred
maxSizeModPred
observedChange <- maxSizeHistObs - maxSizeModObs
observedChange
rm(list=ls(all=TRUE)) # removes all previous material from R's memory
rm(list=ls(all=TRUE))
##### LOAD PACKAGES ETC #####
source("./R/bael_params.R")
source("./R/multiplotF.R")
source("./R/ipmFunctions.R")
library(grid)
# Upload dataframe of modified vital rates
parDFup <- read.csv("./data/parDFup.csv")
head(parDFup)
params <- paramsWA
source("./R/multiplotF.R")
source("./R/ipmFunctions.R")
library(grid)
# Upload dataframe of modified vital rates
parDFup <- read.csv("./data/parDFup.csv")
head(parDFup)
##### MODIFYING THE IPM #####
###1.4.4 Make a kernel###
min.size <- 0.02
max.size <- 1.52
n <- 100 # number of cells in the matrix
b <- min.size+c(0:n)*(max.size-min.size)/n # boundary points (edges of cells defining the matrix)
b
y <- 0.5*(b[1:n]+b[2:(n+1)]) # mesh points (i.e., midpoints to be used in numerical integration)
y
h <- y[2]-y[1] # step size (i.e., width of cells)
h
##### SET UP THE FOR LOOP #####
loopDat <- parDFup
# choose specific rows
AllReps <- unique(loopDat$X)
N <- length(AllReps); N
# Set up a matrix for output data
mat1 <- matrix(nrow = N, ncol = 4)
colnames(mat1) <- c("lambda", "maxSize95", "maxSize99", "meanSize")
# For loop
for(g in 1:N){
param.g <- data.frame(
growth.int = loopDat$growth.int[g],
growth.slope = loopDat$growth.slope[g],
growth.sd = loopDat$growth.sd[g],
embryo.int = loopDat$embryo.int[g],
embryo.slope = loopDat$embryo.slope[g],
mature.size = -loopDat$embryo.int[g]/loopDat$embryo.slope[g],
recruit.size.mean = loopDat$recruit.size.mean[g],
recruit.size.sd = loopDat$recruit.size.mean[g],
estab.prob.mean = loopDat$estab.prob.mean[g],
surv.int = loopDat$surv.int[g],
surv.slope = loopDat$surv.slope[g])
S <- s.x(y, params = param.g) 						# survival
F <- h*outer(y, y, f.yx, params = param.g)  	# reproduction
G <- h*outer(y, y, g.yx, params = param.g) 	# growth
P <- G # placeholder; redefine P on the next line
# fix eviction of offspring
for(i in 1:(n/2)) {
G[1,i] <- G[1,i] + 1-sum(G[,i])
P[,i] <- G[,i]*S[i]
}
# fix eviction of large adults
for(i in (n/2+1):n) {
G[n,i] <- G[n,i] + 1 - sum(G[,i])
P[,i]<-G[,i]*S[i]
}
K <- P + F  			# full matrix
# calculate lambda
lam <- Re(eigen(K)$values[1]) # returns dominant eigenvalue, which gives the asymptotic population growth rate
# calculate max size (99% of stable size distribution)
w.eigen <- Re(eigen(K)$vectors[,1])
stable.dist <- w.eigen/sum(w.eigen)
maxSize95 <- y[min(which(cumsum(stable.dist) > 0.95))]
maxSize99 <- y[min(which(cumsum(stable.dist) > 0.99))]
meanSize <- sum(y*stable.dist)
# population matrix with continuous variables
mat1[g,] <- c(lam, maxSize95, maxSize99, meanSize)
}
mat1
mat2 <- cbind(loopDat[1], mat1)
mat2
##### PREPARE OUTPUT FOR PLOTTING #####
mat2$deltaLambda <- mat2$lambda - mat2$lambda[1]
mat2$delta95 <- mat2$maxSize95 - mat2$maxSize95[1]
mat2$delta99 <- mat2$maxSize99 - mat2$maxSize99[1]
mat2$deltaMean <- mat2$meanSize - mat2$meanSize[1]
mat2$perLambda <- with(mat2, 100 * deltaLambda/mat2$lambda[1])
mat2$per95 <- with(mat2, 100 * delta95/mat2$maxSize95[1])
mat2$per99 <- with(mat2, 100 * delta99/mat2$maxSize99[1])
mat2$perMean <- with(mat2, 100 * deltaMean/mat2$meanSize[1])
fullDat <- mat2
# go from wide to long so that i can use facets
# facets - absolute vs percent change; X
names(fullDat)[1] <- "param"
library(reshape2)
datLong <- melt(fullDat, id.vars = c("param"))
datLong$output <- c(rep("IPM", 48), rep("absolute change", 48),
rep("percent change", 48))
### Select the data I want to plot
ggDat <- droplevels(datLong[datLong$output == "percent change" &
datLong$variable == "perLambda" |
datLong$variable == "per99" |
datLong$variable == "perMean", ])
ggDat2 <- droplevels(ggDat[ggDat$param != "Baseline" &
ggDat$param != "Survival_IS" &
ggDat$param != "Embryo_IS" &
ggDat$param != "Growth_IS" , ])
ggDat3 <- ggDat2
# rename levels of variable
ggDat3$variable <- c(rep("Lambda", 8), rep("Maximum size", 8), rep("Mean size", 8))
# Rename data for plotting
plotDat <- ggDat3
### Plotting details
theme_set(theme_classic(base_size = 12))
dodge <- position_dodge(width = 0)
ULClabel <- theme(plot.title = element_text(hjust = -0.15, vjust = 1, size = rel(1.2)))
# Change order of values
paramOrder <- c("Embryo_intercept", "Embryo_slope", "EstabProb", "RecruitSize",
"Survival_intercept", "Survival_slope", "Growth_intercept", "Growth_slope")
# Change labels
paramLabels <- c("Fecundity\n(intercept)", "Fecundity\n(slope)",
"Recruitment\nprobability", "Recruit size", "Survival\n(intercept)",
"Survival\n(slope)", "Growth\n(intercept)", "Growth\n(slope)")
unique(plotDat$variable)
# Relevel factors of variable
unique(plotDat$variable)
plotDat$variable <- as.factor(plotDat$variable)
print(levels(plotDat$variable))
plotDat$variable <- with(plotDat, factor(variable, levels(variable)[c(1, 3, 2)]))
##### MULTI-PANEL PLOT #####
ULClabel <- theme(plot.title = element_text(hjust = -0.25, vjust = 1, size = rel(1.2)))
sensitivityPlot <- ggplot(plotDat, aes(param, value)) +
geom_bar(stat = "identity", color = "black", fill = "darkgray") +
geom_hline(yintercept = c(0, 10), color = "gray", linetype = "dashed") +
# geom_hline(yintercept = 10, lty = 2, color = "darkgray") +
theme(legend.justification = c(1, 1), legend.position = c(0.95, 0.95)) +
scale_fill_discrete(name = "Perturbation") +
ylab("Percentage change") + xlab("Parameter") +
scale_x_discrete(limits = rev(paramOrder), labels = rev(paramLabels)) +
theme(strip.background = element_blank()) +
# scale_y_continuous(limits = c(-5, 35)) +
theme(axis.text.y = element_text(size = 8)) +
facet_wrap(~ variable) + coord_flip() +
# labs(title = "A") + ULClabel +
theme(panel.margin = unit(1.5, "lines"))
sensitivityPlot
ggsave(file = "./figs/ipm_sensitivity.pdf", height = 3.5, width = 7)
rm(list=ls(all=TRUE))
source("./R/bael_params.R")
source("./R/ipmFunctions.R")
##### MAX AND MIN SIZES #####
names(hist0710)
# Will use slightly larger size range for IPM because
# it is otherwise artificially truncated
min.size <- 0.02
max.size <- 1.5
binSize <- 0.02
binN <- (max.size - min.size)/binSize
binN
##### RUN IPMS #####
### Base IPM, original parameters
ipm1 <- bigmatrix(n = binN, params = paramsWA)
res1 <- popF(ipm1, binSize)
res1[1:8]
# Check for eviction
plot(ipm1$meshpts, s.x(ipm1$meshpts, params), xlab = "Size", type = "l", ylab = "Survival probability", lwd = 12) # plot the survival model
points(ipm1$meshpts, apply(ipm1$P, 2, sum), col = "red", lwd = 3, cex = 0.5, pch = 19) # plot the column sums of the survival/growth matrix
### Modified IPM, with modified embryo and recruitment parameters
ipm2 <- bigmatrix(n = binN, params = paramsCA)
res2 <- popF(ipm2, binSize)
res2
##### PLOTTING #####
pdf("./figs/ipm_histo_fit.pdf", 7, 3.5)
set_graph_pars(ptype = "panel2")
# Panel A
plot(mx.coral ~ areaR, data = ltDat, xlim = c(0, 1.4), ylim = c(-0.025, 40),
xlab = xlab2, ylab = "Embryo number", las = 1, type = "n")
dat <- read.csv("./data/bael_ipmData.csv", header=TRUE, na.strings="NA")
# Select the relevant columns
d <- dat[, which(names(dat) %in%
c("quad", "date", "date.no", "coral.id", "area",
"feret", "code", "sizeOK", "surv", "growth", "recruit"))]
dHIST <- droplevels(d[d$code != "angle" & d$code != "algae" &
d$code != "nv" & d$code != "dead", ])
dHIST <- droplevels(dHIST[complete.cases(dHIST$area), ]) # drop NAs
# include only 2007 and 2010: years for IPM
hist07 <- droplevels(dHIST[dHIST$date.no == 39426, ])
hist10 <- droplevels(dHIST[dHIST$date.no == 40515, ])
hist0710 <- rbind(hist07, hist10)
range(hist0710$area)
# Panel A
plot(mx.coral ~ areaR, data = ltDat, xlim = c(0, 1.4), ylim = c(-0.025, 40),
xlab = xlab2, ylab = "Embryo number", las = 1, type = "n")
# Panel A
plot(mx.coral ~ areaR, data = ltDat, xlim = c(0, 1.4), ylim = c(-0.025, 40),
xlab = xlab2, ylab = "Embryo number", las = 1, type = "n")
xlab2 <- expression(paste("Size (", cm^2, ")"))
# Panel A
plot(mx.coral ~ areaR, data = ltDat, xlim = c(0, 1.4), ylim = c(-0.025, 40),
xlab = xlab2, ylab = "Embryo number", las = 1, type = "n")
abline(mxRegWA, lwd=2, lty=1, col = "darkgray")
abline(mxRegCA, lwd=2, lty=1)
abline(a = 0, b = 0, lty=3, lwd=2, col="darkgray")
points(mx.coral ~ areaR, data = ltDat)
add_panel_label(ltype = "a")
legend("bottomright", "n = 12", cex = 1.1, bty = "n", adj = c(0,-2))
leg.txt <- c("Original", "Modified")
legend("topleft", leg.txt, lwd = 2, bty = "n",
col = c("black", "darkgray"), lty = 1,
cex = 1, text.col = c("black", "darkgray"))
# Panel B
range(hist0710$area)
hist(hist0710$area, breaks = seq(0.0, 1.5, 0.05), freq = FALSE,
xlab = xlab2, ylab="Probability density", col = "gray87", main = "",
ylim = c(-0.025, 2), xlim = c(0, 1.4), border = "gray90", las = 1)
box()
points(ipm1$meshpts , res1$ssd2, type="l", lty=1, lwd = 2,
col = "darkgray")
points(ipm2$meshpts , res2$ssd2, type="l", lty=1, lwd = 2,
col = "black")
add_panel_label(ltype = "b")
arrows(res1$max99, 0.6, res1$max99, 0.3, col = "darkgray",
length = 0.1, lwd = 1.5, angle = 20)
arrows(res2$max99, 0.6, res2$max99, 0.3, col = "black",
length = 0.1, lwd = 1.5, angle = 20)
legend("topright", leg.txt, lwd = 2, bty = "n",
col = c("black", "darkgray"), lty = 1,
cex = 1, text.col = c("black", "darkgray"))
dev.off()
paramsWA
paramsCA
dat$embryosWA <- embryoFwa(dat$area)
dat$embryosCA <- embryoFca(dat$area)
rm(list=ls(all=TRUE))
##### LOAD PACKAGES, DATA #####
library(reshape2)
dat <- read.csv("./data/bael_ipmData.csv", header=TRUE, na.strings="NA")
source("./bael_embryos.R") # this also loads bael_functions
source("./R/graphicalParams.R")
dat$embryosWA <- embryoFwa(dat$area)
dat$embryosCA <- embryoFca(dat$area)
# Calculate density for each quadrat and year
density.q <- tapply(dat$area, list(dat$quad, dat$date.no), FUN=densityF)
density.q
dat$embryosWA <- embryoFwa(dat$area)
dat$embryosCA <- embryoFca(dat$area)
# Calculate density for each quadrat and year
density.q <- tapply(dat$area, list(dat$quad, dat$date.no), FUN=densityF)
density.q
### Calculate number of embryos for each quadrat and year
embryoWA.q <- tapply(dat$embryosWA, list(dat$quad, dat$date.no), FUN=sum, na.rm=TRUE)
colnames(embryoWA.q) <- c("2007", "2008", "2009", "2010")
# remove the last column, because the embryo no. in 2010 is irrelevant
eq <- embryoWA.q[,-4]
eqWA <- embryoWA.q[,-4]
embryoCA.q <- tapply(dat$embryosCA, list(dat$quad, dat$date.no), FUN=sum, na.rm=TRUE)
colnames(embryoCA.q) <- c("2007", "2008", "2009", "2010")
### Calculate number of embryos for each quadrat and year - CA
embryoCA.q <- tapply(dat$embryosCA, list(dat$quad, dat$date.no), FUN=sum, na.rm=TRUE)
colnames(embryoCA.q) <- c("2007", "2008", "2009", "2010")
# remove the last column, because the embryo no. in 2010 is irrelevant
eqCA <- embryoCA.q[,-4]
eqCASum <- rowSums(eqCA)
names(dat)
# Select the relevant columns
d <- dat[, which(names(dat) %in% c("quad", "date", "date.no",
"coral.id", "area", "feret", "code", "sizeOK", "surv", "growth", "recruit"))]
# Get data at time 3
unique(d$date.no)
dT03 <- droplevels(d[d$date.no == 39426 | d$date.no == 40515, ])
summary(dT03)
dT0 <- droplevels(dT03[dT03$date.no == 39426, ])
dT3 <- droplevels(dT03[dT03$date.no == 40515, ])
recruitDat <- d[d$recruit == 1,]
# create dataframe with code coral.id for recruitDat
recruitDat2 <- droplevels(recruitDat[, which(names(recruitDat) %in%
c("coral.id", "code"))])
dim(recruitDat2)
names(recruitDat2) <- c("coral.id", "recruitCode")
head(recruitDat2)
summary(recruitDat2)
dT3b <- merge(dT3, recruitDat2, all.x = TRUE)
# Calculate recruit density in T3
recruit.qT3 <- tapply(dT3b$recruitCode, list(dT3$quad, dT3$date.no), FUN=recruitF)
recruit.qT3
eqSum
eqWASum
eqCASum
eqCASum; eqWASum
# Use embryo function for Washington and California
dat$embryosWA <- embryoFwa(dat$area)
dat$embryosCA <- embryoFca(dat$area)
### Calculate number of embryos for each quadrat and year - WA
embryoWA.q <- tapply(dat$embryosWA, list(dat$quad, dat$date.no), FUN=sum, na.rm=TRUE)
colnames(embryoWA.q) <- c("2007", "2008", "2009", "2010")
# remove the last column, because the embryo no. in 2010 is irrelevant
eqWA <- embryoWA.q[,-4]
eqWASum <- rowSums(eqWA)
### Calculate number of embryos for each quadrat and year - CA
embryoCA.q <- tapply(dat$embryosCA, list(dat$quad, dat$date.no), FUN=sum, na.rm=TRUE)
colnames(embryoCA.q) <- c("2007", "2008", "2009", "2010")
# remove the last column, because the embryo no. in 2010 is irrelevant
eqCA <- embryoCA.q[,-4]
eqCASum <- rowSums(eqCA)
recProbSum <- (recruit.qT3/eqSumCA) * 100;
recProbSum <- (recruit.qT3/eqCASum) * 100;
recProb2 <- recProbSum
recProb2[is.infinite(recProb2)] <- NaN
recProb2
recProbCA <- recProb2
recProbSum <- (recruit.qT3/eqSumWA) * 100;
recProb2 <- recProbSum
recProb2[is.infinite(recProb2)] <- NaN
recProb2
recProbWA <- recProb2
recProbCA; recProbWA
plot(recProbWA ~ recProbCA)
recProbSum <- (recruit.qT3/eqWASum) * 100;
recProb2 <- recProbSum
recProb2[is.infinite(recProb2)] <- NaN
recProb2
recProbWA <- recProb2
plot(recProbWA ~ recProbCA)
rm(list=ls(all=TRUE))
##### SET UP DATAFRAME TO STORE MODEL PARAMETERS #####
params <- data.frame(
surv.int=NA,			# Intercept from logistic regression of survival
surv.slope=NA,	# Slope from logistic regression of survival
mature.size=NA,  # Size at maturity
embryo.int=NA,			# Intercept from linear regression of embryo number
embryo.slope=NA,		# Slope from linear regression of embryo number
embryo.sd=NA,   # Residual sd from the linear regression of embryo number
recruit.size.mean=NA, # Mean recruit size
recruit.size.sd=NA,   # Standard deviation of recruit size
estab.prob.mean=NA, # Mean of establishment probability
estab.prob.sd=NA,      # SD of establishment probability
growth.int=NA,  	# Intercept from linear regression of growth
growth.slope=NA,	# Slope from linear regression of growth
growth.sd=NA		# Residual sd from the linear regression of growth
)
##### SURVIVAL FUNCTION #####
source("./bael_survival.R")
# These are the relevant outputs
presMod
pastMod
# Rename relevant model
survMod <- presMod
# Store vital rate parameters
params$surv.int <- summary(survMod)[[10]][1]
params$surv.slope <- summary(survMod)[[10]][2]
params
##### GROWTH FUNCTION #####
source("./bael_growth.R")
# These are the relevant outputs
presMod
pastMod
# Rename relevant model
growthMod <- presMod
# Store vital rate parameters
params$growth.int <- summary(growthMod)[[10]][1]
params$growth.slope <- summary(growthMod)[[10]][2]
params$growth.sd <- sd(resid(growthMod))
params
##### SIZE DISTRIBUTION OF RECRUITS #####
dat <- read.csv("./data/bael_recruitSizeData.csv", header=TRUE, na.strings="NA")
datPres <- dat[dat$time == "present", ]
# Store vital rate parameters
params$recruit.size.mean <- mean(datPres$area)
params$recruit.size.sd <- sd(datPres$area)
params
##### CREATE FORK FOR CALIFORNIA AND WASHINGTON #####
# The embryo function is originally from California,
# and was modified using the Arrhenius equation for Washington,
# which has colder seawater
# The modified embryo-size function causes downstream changes to
# size at maturity and establishment probability
paramsWA <- params
paramsCA <- params
##### EMBRYO FUNCTION #####
# Note that the embryo function determines size at maturity and
# establishment probability
source("./bael_embryos.R")
# These are the relevant outputs
mxRegWA
mxRegCA
# Store vital rate parameters for California
paramsCA$embryo.int <- coefficients(mxRegCA)[1]
paramsCA$embryo.slope <- coefficients(mxRegCA)[2]
paramsCA$embryo.sd <- sd(resid(mxRegCA))
# Store vital rate parameters for Washington
paramsWA$embryo.int <- coefficients(mxRegWA)[1]
paramsWA$embryo.slope <- coefficients(mxRegWA)[2]
paramsWA$embryo.sd <- sd(resid(mxRegWA))
paramsCA
paramsWA
##### SIZE AT MATURITY #####
paramsCA$mature.size <- -paramsCA$embryo.int/paramsCA$embryo.slope
paramsWA$mature.size <- -paramsWA$embryo.int/paramsCA$embryo.slope
source("./bael_establishment.R")
paramsWA$estab.prob.mean <- mean(recProbWA/100, na.rm = TRUE)
paramsWA$estab.prob.sd <- sd(recProbWA/100, na.rm = TRUE)
paramsCA$estab.prob.mean <- mean(recProbCA/100, na.rm = TRUE)
paramsCA$estab.prob.sd <- sd(recProbCA/100, na.rm = TRUE)
params
source("./bael_establishment.R")
paramsWA$estab.prob.mean <- mean(recProbWA/100, na.rm = TRUE)
paramsWA$estab.prob.sd <- sd(recProbWA/100, na.rm = TRUE)
paramsCA$estab.prob.mean <- mean(recProbCA/100, na.rm = TRUE)
paramsCA$estab.prob.sd <- sd(recProbCA/100, na.rm = TRUE)
paramsWA
paramsCA
paramsWA
rm(list=ls(all=TRUE))
##### LOAD PACKAGES ETC #####
source("./R/bael_params.R")
# source("./R/baelParamsCA.R")
source("./R/ipmFunctions.R")
# Data from ipmData.csv:
dat <- read.csv("./data/bael_ipmData.csv", header=TRUE, na.strings="NA")
# Select the relevant columns
d <- dat[, which(names(dat) %in%
c("quad", "date", "date.no", "coral.id", "area",
"feret", "code", "sizeOK", "surv", "growth", "recruit"))]
dHIST <- droplevels(d[d$code != "angle" & d$code != "algae" &
d$code != "nv" & d$code != "dead", ])
dHIST <- droplevels(dHIST[complete.cases(dHIST$area), ]) # drop NAs
# include only 2007 and 2010: years for IPM
hist07 <- droplevels(dHIST[dHIST$date.no == 39426, ])
hist10 <- droplevels(dHIST[dHIST$date.no == 40515, ])
hist0710 <- rbind(hist07, hist10)
range(hist0710$area)
##### MAX AND MIN SIZES #####
# Will use slightly larger size range for IPM because
# it is otherwise artificially truncated
min.size <- 0.02
max.size <- 1.5
binSize <- 0.02
binN <- (max.size - min.size)/binSize
binN
##### RUN IPMS #####
### Base IPM, original parameters
ipm1 <- bigmatrix(n = binN, params = paramsWA)
res1 <- popF(ipm1, binSize)
res1[1:8]
# Check for eviction
plot(ipm1$meshpts, s.x(ipm1$meshpts, params), xlab = "Size", type = "l", ylab = "Survival probability", lwd = 12) # plot the survival model
points(ipm1$meshpts, apply(ipm1$P, 2, sum), col = "red", lwd = 3, cex = 0.5, pch = 19) # plot the column sums of the survival/growth matrix
### Modified IPM, with modified embryo and recruitment parameters
ipm2 <- bigmatrix(n = binN, params = paramsCA)
res2 <- popF(ipm2, binSize)
res2
##### PLOTTING #####
pdf("./figs/ipm_histo_fit.pdf", 7, 3.5)
set_graph_pars(ptype = "panel2")
xlab2 <- expression(paste("Size (", cm^2, ")"))
# Panel A
plot(mx.coral ~ areaR, data = ltDat, xlim = c(0, 1.4), ylim = c(-0.025, 40),
xlab = xlab2, ylab = "Embryo number", las = 1, type = "n")
abline(mxRegWA, lwd=2, lty=1, col = "darkgray")
abline(mxRegCA, lwd=2, lty=1)
abline(a = 0, b = 0, lty=3, lwd=2, col="darkgray")
points(mx.coral ~ areaR, data = ltDat)
add_panel_label(ltype = "a")
legend("bottomright", "n = 12", cex = 1.1, bty = "n", adj = c(0,-2))
leg.txt <- c("Original", "Modified")
legend("topleft", leg.txt, lwd = 2, bty = "n",
col = c("black", "darkgray"), lty = 1,
cex = 1, text.col = c("black", "darkgray"))
# Panel B
range(hist0710$area)
hist(hist0710$area, breaks = seq(0.0, 1.5, 0.05), freq = FALSE,
xlab = xlab2, ylab="Probability density", col = "gray87", main = "",
ylim = c(-0.025, 2), xlim = c(0, 1.4), border = "gray90", las = 1)
box()
points(ipm1$meshpts , res1$ssd2, type="l", lty=1, lwd = 2,
col = "darkgray")
points(ipm2$meshpts , res2$ssd2, type="l", lty=1, lwd = 2,
col = "black")
add_panel_label(ltype = "b")
arrows(res1$max99, 0.6, res1$max99, 0.3, col = "darkgray",
length = 0.1, lwd = 1.5, angle = 20)
arrows(res2$max99, 0.6, res2$max99, 0.3, col = "black",
length = 0.1, lwd = 1.5, angle = 20)
legend("topright", leg.txt, lwd = 2, bty = "n",
col = c("black", "darkgray"), lty = 1,
cex = 1, text.col = c("black", "darkgray"))
dev.off()
##### INFORMAL TESTS OF IPM SENSITIVITY #####
paramsWA
res2[1:4] # results of the modified IPM using WA parameters
paramsTest <- paramsWA; paramsTest$surv.slope = 0.5
paramsTest <- paramsWA; paramsTest$surv.int = 3
paramsTest <- paramsWA; paramsTest$growth.slope = 0.5
paramsTest <- paramsWA; paramsTest$growth.int = 0.1
ipmTest <- bigmatrix(n = binN, params = paramsTest)
resTest <- popF(ipmTest, binSize)
resTest[1:4]
