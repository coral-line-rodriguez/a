head(simulationDF)
simulationDF <- growthGrid %>% select(Kelvin:row) %>% rename(simulation == row)
simulationDF <- growthGrid %>% select(Kelvin:row) %>%
rename(simulation = row)
head(simulationDF)
growthDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$vec_slope)
head(growthDF)
growthDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$vec_slope,
survivalGrid$const_int, survivalGrid$const_int) %>%
head(growthDF)
growthDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$vec_slope,
survivalGrid$const_int, survivalGrid$const_int)
head(growthDF)
params
growthDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$vec_slope,
survivalGrid$const_int, survivalGrid$const_slope) %>%
rename(growth.int = growthGrid$const_int, growth.slope = growthGrid$vec_slope,
surv.int = survivalGrid$const_int, surv.slope = survivalGrid$const_slope)
head(growthDF)
names(growthDF)
names(growthDF)[, 4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
names(growthDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
names(growthDF)
growthDF$parameter <- "Growth"
survDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$const_int,
survivalGrid$const_int, survivalGrid$vec_slope)
names(survDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
growthDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$vec_slope,
survivalGrid$const_int, survivalGrid$const_slope)
names(growthDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
growthDF$parameter <- "Growth"
# Survival: constant intercept, but variable slope
survDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$const_int,
survivalGrid$const_int, survivalGrid$vec_slope)
names(survDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
survDF$parameter <- "Survival"
# Growth: constant intercept, but variable slope
growthDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$vec_slope,
survivalGrid$const_int, survivalGrid$const_slope)
names(growthDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
growthDF$parameter <- "Growth"
# Survival: constant intercept, but variable slope
survDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$const_slope,
survivalGrid$const_int, survivalGrid$vec_slope)
names(survDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
survDF$parameter <- "Survival"
# Survival and Growth: variable slopes for both
survGrowthDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$vec_slope,
survivalGrid$const_int, survivalGrid$vec_slope)
names(survGrowthDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
survGrowthDF$parameter <- "Survival and growth"
masterDF <- rbind(growthDF, survDF, survGrowthDF)
head(masterDF)
###1.4.4 Make a kernel###
min.size <- .9*min(c(growthDat$size,growthDat$sizeNext), na.rm=T)
max.size <- 1.1*max(c(growthDat$size,growthDat$sizeNext), na.rm=T)
min.size <- 0.02
max.size <- 2.02
n <- 100 # number of cells in the matrix
b <- min.size+c(0:n)*(max.size-min.size)/n # boundary points (edges of cells defining the matrix)
b
y <- 0.5*(b[1:n]+b[2:(n+1)]) # mesh points (i.e., midpoints to be used in numerical integration)
y
h <- y[2]-y[1] # step size (i.e., width of cells)
h
loopDat <- masterDF
AllReps <- unique(loopDat$row)
N <- length(AllReps); N
masterDF$row <- seq(1:nrow(masterDF))
tail(masterDF)
### Set up a for loop to run the IPM simulations
loopDat <- masterDF
AllReps <- unique(loopDat$row)
N <- length(AllReps); N
# Create a matrix to store the results
mat1 <- matrix(nrow = N, ncol = 4)
colnames(mat1) <- c("lambda", "maxSize95", "maxSize99", "meanSize")
# Loop over each row in masterDF
for(g in 1:N){
row.g <- AllReps[g]
param.g <- data.frame(
growth.int = loopDat$growth.int[row.g],
growth.slope = loopDat$growth.slope[row.g],
growth.sd = params$growth.sd,
embryo.int = params$embryo.int,
embryo.slope = params$embryo.slope,
mature.size = - params$embryo.int/params$embryo.slope,
recruit.size.mean = params$recruit.size.mean,
recruit.size.sd = params$recruit.size.sd,
estab.prob.mean = params$estab.prob.mean,
surv.int = loopDat$surv.int,
surv.slope = loopDat$surv.slope)
S <- s.x(y, params = param.g) 						# survival
F <- h*outer(y, y, f.yx, params = param.g)  	# reproduction
G <- h*outer(y, y, g.yx, params = param.g) 	# growth
P <- G # placeholder; redefine P on the next line
# fix eviction of offspring
for(i in 1:(n/2)) {
G[1,i] <- G[1,i] + 1-sum(G[,i])
P[,i] <- G[,i]*S[i]
}
# fix eviction of large adults
for(i in (n/2+1):n) {
G[n,i] <- G[n,i] + 1 - sum(G[,i])
P[,i]<-G[,i]*S[i]
}
K <- P + F  			# full matrix
# calculate lambda
lam <- Re(eigen(K)$values[1]) # returns dominant eigenvalue, which gives the asymptotic population growth rate
# calculate max size (99% of stable size distribution)
w.eigen <- Re(eigen(K)$vectors[,1])
stable.dist <- w.eigen/sum(w.eigen)
maxSize95 <- y[min(which(cumsum(stable.dist) > 0.95))]
maxSize99 <- y[min(which(cumsum(stable.dist) > 0.99))]
meanSize <- sum(y*stable.dist)
# populate matrix with continuous variables
mat1[g,] <- c(lam, maxSize95, maxSize99, meanSize)
}
head(mat1)
warnings()
head(loopDat)
mat1 <- matrix(nrow = N, ncol = 4)
colnames(mat1) <- c("lambda", "maxSize95", "maxSize99", "meanSize")
# Loop over each row in masterDF
for(g in 1:N){
row.g <- AllReps[g]
param.g <- data.frame(
growth.int = loopDat$growth.int[row.g],
growth.slope = loopDat$growth.slope[row.g],
growth.sd = params$growth.sd,
embryo.int = params$embryo.int,
embryo.slope = params$embryo.slope,
mature.size = - params$embryo.int/params$embryo.slope,
recruit.size.mean = params$recruit.size.mean,
recruit.size.sd = params$recruit.size.sd,
estab.prob.mean = params$estab.prob.mean,
surv.int = loopDat$surv.int[row.g],
surv.slope = loopDat$surv.slope[row.g])
S <- s.x(y, params = param.g) 						# survival
F <- h*outer(y, y, f.yx, params = param.g)  	# reproduction
G <- h*outer(y, y, g.yx, params = param.g) 	# growth
P <- G # placeholder; redefine P on the next line
# fix eviction of offspring
for(i in 1:(n/2)) {
G[1,i] <- G[1,i] + 1-sum(G[,i])
P[,i] <- G[,i]*S[i]
}
# fix eviction of large adults
for(i in (n/2+1):n) {
G[n,i] <- G[n,i] + 1 - sum(G[,i])
P[,i]<-G[,i]*S[i]
}
K <- P + F  			# full matrix
# calculate lambda
lam <- Re(eigen(K)$values[1]) # returns dominant eigenvalue, which gives the asymptotic population growth rate
# calculate max size (99% of stable size distribution)
w.eigen <- Re(eigen(K)$vectors[,1])
stable.dist <- w.eigen/sum(w.eigen)
maxSize95 <- y[min(which(cumsum(stable.dist) > 0.95))]
maxSize99 <- y[min(which(cumsum(stable.dist) > 0.99))]
meanSize <- sum(y*stable.dist)
# populate matrix with continuous variables
mat1[g,] <- c(lam, maxSize95, maxSize99, meanSize)
}
head(mat1)
mat2 <- cbind(masterDF, mat1)
mat2$Ea <- as.factor(mat2$Ea)
simDat <- mat2
label1 <- expression(paste("Maximum size (", cm^2, ")"))
tempLab <- expression(paste("Temperature (", degree, "C)"))
regression <- geom_smooth(method = "lm", se = FALSE, alpha = 0.5,
size = 0.4)
ULClabel <- theme(plot.title = element_text(hjust = -0.07, vjust = 1,
size = rel(1.5)))
range(simDat$maxSize99)
h
max.size <- 1.1*max(c(growthDat$size,growthDat$sizeNext), na.rm=T)
max.size
min.size <- 0.02
max.size <- 1.82
n <- 100 # number of cells in the matrix
b <- min.size+c(0:n)*(max.size-min.size)/n # boundary points (edges of cells defining the matrix)
b
y <- 0.5*(b[1:n]+b[2:(n+1)]) # mesh points (i.e., midpoints to be used in numerical integration)
y
h <- y[2]-y[1] # step size (i.e., width of cells)
h
min.size <- 0.02
max.size <- 2.02
n <- 100 # number of cells in the matrix
b <- min.size+c(0:n)*(max.size-min.size)/n # boundary points (edges of cells defining the matrix)
b
y <- 0.5*(b[1:n]+b[2:(n+1)]) # mesh points (i.e., midpoints to be used in numerical integration)
y
h <- y[2]-y[1] # step size (i.e., width of cells)
h
label1 <- expression(paste("Maximum size (", cm^2, ")"))
tempLab <- expression(paste("Temperature (", degree, "C)"))
regression <- geom_smooth(method = "lm", se = FALSE, alpha = 0.5,
size = 0.4)
ULClabel <- theme(plot.title = element_text(hjust = -0.07, vjust = 1,
size = rel(1.5)))
range(simDat$maxSize99)
# Max size
maxSizePlot <- ggplot(data = simDat,
aes((Kelvin-273.15), maxSize99, color = Ea)) +
xlab(tempLab) + ylab(label1) +
geom_point(alpha = 0.5, size = 0) +
geom_smooth(se = FALSE, size = 0.7) +
theme(legend.justification = c(1,1), legend.position = c(1.1, 1.1)) +
scale_color_discrete(name = "Activation\nenergy") +
guides(color = guide_legend(reverse=TRUE)) +
coord_cartesian(ylim = c(0.9, 1.75))
maxSizePlot
theme_set(theme_classic(base_size = 12))
names(hist0710)
range(hist0710$area)
# Present size data already stored here, from ipmData.csv:
names(hist0710)
range(hist0710$area)
# Past size data in histoData.csv:
dat <- read.csv("./data/bael_histoData.csv", header=TRUE, na.strings="NA")
head(dat)
### Initial data
unique(dat$ini.notes)
ini.dat <- droplevels(dat[dat$ini.notes != "angle" & dat$ini.notes != "fuzzy" &
dat$ini.notes != "gone" & dat$ini.notes != "nv" &
dat$ini.notes != "tentacles", ])
ini.dat <- droplevels(ini.dat[complete.cases(ini.dat$ini.area), ]) # drop NAs
dim(ini.dat)
### Final data
unique(dat$fin.notes)
fin.dat <- droplevels(dat[dat$fin.notes != "angle" & dat$fin.notes != "fuzzy" &
dat$fin.notes != "gone" & dat$fin.notes != "nv" &
dat$fin.notes != "tentacles" & dat$fin.notes != "algae" &
dat$fin.notes != "dead" & dat$fin.notes != "overgrown", ])
fin.dat <- droplevels(fin.dat[complete.cases(fin.dat$fin.area), ]) # drop NAs
unique(fin.dat$fin.notes)
dim(fin.dat)
ini.sc<- subset(ini.dat, site=="SC")
fin.sc <- subset(fin.dat, site == "SC")
ini.sc$tempC <- with(ini.sc, ifelse(time == "past", hisTemp-273.15, modTemp-273.15))
fin.sc$tempC <- with(fin.sc, ifelse(time == "past", hisTemp-273.15, modTemp-273.15))
# Initial data
ggplot(ini.sc, aes(tempC, ini.area)) +
geom_violin(alpha = I(0.5), aes(color = time),
position = position_jitter(width = 0.01))
# Final data
ggplot(fin.sc, aes(tempC, fin.area)) +
geom_violin(alpha = I(0.5), aes(color = time),
position = position_jitter(width = 0.01))
initialSize <- ini.sc %>% group_by(time) %>%
summarise(maxSize = max(ini.area))
finalSize <- fin.sc %>% group_by(time) %>%
summarise(maxSize = max(fin.area))
initialSize
finalSize
sizeObs <- initialSize
sizeObs$tempC <- c(hisTemp-273.15, modTemp-273.15)
# substitute max size from largest observed size (to match past data)
sizeObs$maxSize[2] <- max(hist0710$area)
sizeObs
sizeObs
# observed points
maxObs <- geom_point(aes(tempC, maxSize),
data = sizeObs,
size = 3, shape = 16, color = c("darkgray", 1))
maxSizePlot + maxObs
ggsave("./figs/ipm_temp.pdf", width = 3.5, height = 3.5)
ggplot(data = simDat,
aes((Kelvin-273.15), maxSize99, color = Ea)) +
xlab(tempLab) + ylab(label1) +
geom_point(alpha = 0.5, size = 0) +
geom_smooth(se = FALSE, size = 0.7) +
theme(legend.justification = c(1,1), legend.position = c(1.1, 1.1)) +
scale_color_discrete(name = "Activation\nenergy") +
guides(color = guide_legend(reverse=TRUE)) +
coord_cartesian(ylim = c(0.9, 1.75)) +
facet_wrap(~ parameter)
maxSizePlot <- ggplot(data = simDat,
aes((Kelvin-273.15), maxSize99, color = Ea)) +
xlab(tempLab) + ylab(label1) +
geom_point(alpha = 0.5, size = 0) +
geom_smooth(se = FALSE, size = 0.7) +
theme(legend.justification = c(1,1), legend.position = c(1.1, 1.1)) +
scale_color_discrete(name = "Activation\nenergy") +
guides(color = guide_legend(reverse=TRUE)) +
coord_cartesian(ylim = c(0.9, 1.75)) +
facet_wrap(~ parameter)
maxSizePlot
maxSizePlot + maxObs
ggsave("./figs/ipm_temp.pdf", width = 3.5, height = 3.5)
ggsave("./figs/ipm_temp.pdf", width = 7, height = 3.5)
rm(list=ls(all=TRUE))
source("./R/baelParamsWA.R")
source("./R/multiplotF.R")
params
################################################
#### MODIFYING THE IPM
#### CHANGE EACH PARAMETER BY 10%
#### CALCULATE NEW MAX 95, 99, MEAN, LAMBDA
################################################
# params
# # what will I actually change?
# parDF <- params
# parDF
#
# # remove mature size
# parDF$mature.size <- NULL
# parDF
# write.csv(parDF, "parDF.csv")
# upload relevant scenarios
parDFup <- read.csv("./data/parDFup.csv")
###1.4.4 Make a kernel###
min.size <- 0.02
max.size <- 1.5
binSize <- 0.02
n <- (max.size - min.size)/binSize # number of cells in the matrix
b <- min.size+c(0:n)*(max.size-min.size)/n # boundary points (edges of cells defining the matrix)
b
y <- 0.5*(b[1:n]+b[2:(n+1)]) # mesh points (i.e., midpoints to be used in numerical integration)
y
h <- y[2]-y[1] # step size (i.e., width of cells)
h
### Now calculate lambda and max size of the stable size distribution after running the ipm
# as a function of different temps
head(parDFup)
# for loop
loopDat <- parDFup
dim(loopDat)
# choose specific rows
AllReps <- unique(loopDat$X)
AllReps
N <- length(AllReps); N
######################################
######################################
### CHANGE GROWTH INT AND SLOPE
######################################
######################################
# matrix
mat1 <- matrix(nrow = N, ncol = 4)
colnames(mat1) <- c("lambda", "maxSize95", "maxSize99", "meanSize")
mat1
head(loopDat)
# Loop over each row in loopDat; get lambda and maxSize
for(g in 1:N){
row.g <- AllReps[g]
param.g <- data.frame(
growth.int = loopDat$growth.int[row.g],
growth.slope = loopDat$growth.slope[row.g],
growth.sd = loopDat$growth.sd[row.g],
embryo.int = loopDat$embryo.int[row.g],
embryo.slope = loopDat$embryo.slope[row.g],
mature.size = -loopDat$embryo.int[row.g]/loopDat$embryo.slope[row.g],
recruit.size.mean = loopDat$recruit.size.mean[row.g],
recruit.size.sd = loopDat$recruit.size.mean[row.g],
estab.prob.mean = loopDat$estab.prob.mean[row.g],
surv.int = loopDat$surv.int[row.g],
surv.slope = loopDat$surv.slope[row.g])
S <- s.x(y, params = param.g) 						# survival
F <- h*outer(y, y, f.yx, params = param.g)  	# reproduction
G <- h*outer(y, y, g.yx, params = param.g) 	# growth
P <- G # placeholder; redefine P on the next line
# fix eviction of offspring
for(i in 1:(n/2)) {
G[1,i] <- G[1,i] + 1-sum(G[,i])
P[,i] <- G[,i]*S[i]
}
# fix eviction of large adults
for(i in (n/2+1):n) {
G[n,i] <- G[n,i] + 1 - sum(G[,i])
P[,i]<-G[,i]*S[i]
}
K <- P + F  			# full matrix
# calculate lambda
lam <- Re(eigen(K)$values[1]) # returns dominant eigenvalue, which gives the asymptotic population growth rate
# calculate max size (99% of stable size distribution)
w.eigen <- Re(eigen(K)$vectors[,1])
stable.dist <- w.eigen/sum(w.eigen)
maxSize95 <- y[min(which(cumsum(stable.dist) > 0.95))]
maxSize99 <- y[min(which(cumsum(stable.dist) > 0.99))]
meanSize <- sum(y*stable.dist)
# population matrix with continuous variables
mat1[g,] <- c(lam, maxSize95, maxSize99, meanSize)
}
mat1
mat2 <- cbind(loopDat[1], mat1)
mat2
mat2$deltaLambda <- mat2$lambda - mat2$lambda[1]
mat2$delta95 <- mat2$maxSize95 - mat2$maxSize95[1]
mat2$delta99 <- mat2$maxSize99 - mat2$maxSize99[1]
mat2$deltaMean <- mat2$meanSize - mat2$meanSize[1]
mat2$perLambda <- with(mat2, 100 * deltaLambda/mat2$lambda[1])
mat2$per95 <- with(mat2, 100 * delta95/mat2$maxSize95[1])
mat2$per99 <- with(mat2, 100 * delta99/mat2$maxSize99[1])
mat2$perMean <- with(mat2, 100 * deltaMean/mat2$meanSize[1])
mat2
fullDat <- mat2
names(fullDat)
# go from wide to long so that i can use facets
# facets - absolute vs percent change; X
names(fullDat)[1] <- "param"
library(reshape2)
datLong <- melt(fullDat, id.vars = c("param"))
head(datLong)
dim(datLong)
datLong$output <- c(rep("IPM", 48), rep("absolute change", 48), rep("percent change", 48))
datLong
summary(datLong)
unique(datLong$variable)
unique(datLong$param)
#write.csv(datLong, "sensitivityDatLong_150423.csv")
####
# read in sensitivity data
#####
ggDat <- droplevels(datLong[datLong$output == "percent change" &
datLong$variable == "perLambda" |
datLong$variable == "per99" |
datLong$variable == "perMean", ])
dim(ggDat)
ggDat2 <- droplevels(ggDat[ggDat$param != "Baseline" &
ggDat$param != "Survival_IS" &
ggDat$param != "Embryo_IS" &
ggDat$param != "Growth_IS" , ])
dim(ggDat2)
unique(ggDat2$param)
unique(ggDat2$variable)
unique(ggDat2$output)
ggDat3 <- ggDat2
ggDat3
dim(ggDat3)
# rename levels of variable
ggDat3$variable <- c(rep("Lambda", 8), rep("Maximum size", 8), rep("Mean size", 8))
ggDat3
####
plotDat <- ggDat3
plotDat
dodge <- position_dodge(width = 0)
theme_set(theme_classic(base_size = 12))
plotDat$param
head(plotDat)
# want to change order of values
paramOrder <- c("Embryo_intercept", "Embryo_slope", "EstabProb", "RecruitSize",
"Survival_intercept", "Survival_slope", "Growth_intercept", "Growth_slope")
paramOrder
plotDat
# Survival: constant intercept, but variable slope
survDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$const_slope,
survivalGrid$const_int, survivalGrid$vec_slope)
names(survDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
survDF$parameter <- "Survival"
head(survDF)
rm(list=ls(all=TRUE)) # removes all previous material from R's memory
##### LOAD PACKAGES ETC #####
library(fields) # need for image.plot
library(ggplot2)
theme_set(theme_classic(base_size = 12))
library(dplyr)
source("./R/baelParamsWA.R")
source("./R/metabolicTheory.R")
source("./R/multiplotF.R")
source("./R/modify_vital_rates.R")
# Temperatures
modTemp <- 9.25 + 273.15
hisTemp <- 8.6 + 273.15
#### SET GLOBAL PARAMETERS FOR THE SIMULATIONS #####
### Range of activation energies; 0.2 - 1.2
lowerEa <- 0.2; upperEa <- 1.2; Ea_increment <- 0.2
### Range of temperatures; 8-9.5 degrees C
lowerTemp <- 281.5; upperTemp <- 282.65; temp_increment <- 0.05;
originalTemp <- modTemp
##### MODIFYING VITAL RATES WITH THE ARRHENIUS EQUATION: GROWTH #####
growthGrid <- modifyVitalRates(slope = params$growth.slope, slopeTempEffect = "neg",
intercept = params$growth.int, interceptTempEffect = "pos",
lowerEa, upperEa, Ea_increment,
lowerTemp, upperTemp, temp_increment,
originalTemp)
head(growthGrid)
# sample plot of the slope as a function of temperature and Ea ####
ggplot(grid1, aes((Kelvin-273.15),
vec_slope, color = as.factor(Ea))) +
geom_point(alpha = 0.2, size = 2) + theme_bw() +
xlab("Temperature (C)") + ylab("") +
geom_smooth(se = FALSE) +
theme(legend.justification = c(1,1), legend.position = c(1, 1)) +
guides(color = guide_legend(reverse=TRUE)) +
scale_color_discrete(name = "Activation\nEnergy") +
theme(text = element_text(size = 18)) +
theme(legend.title = element_text(size = 12)) +
theme(legend.text = element_text(size = 12))
##### MODIFYING VITAL RATES WITH THE ARRHENIUS EQUATION: SURVIVAL #####
survivalGrid <- modifyVitalRates(slope = params$surv.slope, slopeTempEffect = "neg",
intercept = params$surv.int, interceptTempEffect = "neg",
lowerEa, upperEa, Ea_increment,
lowerTemp, upperTemp, temp_increment,
originalTemp)
head(survivalGrid)
##### COLLATE VITAL RATES INTO FINAL DATAFRAME FOR IPMS #####
simulationDF <- growthGrid %>% select(Kelvin:row) %>%
rename(simulation = row)
# Growth: constant intercept, but variable slope
growthDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$vec_slope,
survivalGrid$const_int, survivalGrid$const_slope)
names(growthDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
growthDF$parameter <- "Growth"
# Survival: constant intercept, but variable slope
survDF <- cbind(simulationDF, growthGrid$const_int, growthGrid$const_slope,
survivalGrid$const_int, survivalGrid$vec_slope)
names(survDF)[4:7] <- c("growth.int", "growth.slope", "surv.int", "surv.slope")
survDF$parameter <- "Survival"
head(survDF)
range(survDF$surv.slope)
